/**
 * ReFlow Template Utilities (Auto-generated)
 * 
 * This file is automatically generated from TypeScript sources.
 * Do not edit directly. Edit files in lib/template-utils/ instead.
 * 
 * Generated on: 2025-07-05T19:13:13.272Z
 */

"use strict";
var templateUtils = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // lib/template-utils/index.ts
  var index_exports = {};
  __export(index_exports, {
    background: () => background_exports,
    canvas: () => canvas_exports,
    color: () => color_exports,
    debug: () => debug_exports,
    math: () => math_exports,
    shape: () => shape_exports,
    utils: () => utils
  });

  // lib/template-utils/canvas.ts
  var canvas_exports = {};
  __export(canvas_exports, {
    clear: () => clear,
    drawPath: () => drawPath,
    drawRoundedPolygon: () => drawRoundedPolygon,
    fillCircle: () => fillCircle,
    fillRect: () => fillRect,
    fillText: () => fillText,
    measureText: () => measureText,
    strokeCircle: () => strokeCircle,
    strokeRect: () => strokeRect,
    withState: () => withState,
    withTransform: () => withTransform
  });
  function clear(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
  }
  function fillRect(ctx, x, y, width, height, radius = 0) {
    if (radius <= 0) {
      ctx.fillRect(x, y, width, height);
      return;
    }
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }
  function strokeRect(ctx, x, y, width, height, radius = 0) {
    if (radius <= 0) {
      ctx.strokeRect(x, y, width, height);
      return;
    }
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.stroke();
  }
  function fillCircle(ctx, x, y, radius) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }
  function strokeCircle(ctx, x, y, radius) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
  }
  function drawPath(ctx, points, closePath = false) {
    if (points.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    if (closePath) {
      ctx.closePath();
    }
  }
  function fillText(ctx, text, x, y, options = {}) {
    const savedFont = ctx.font;
    const savedAlign = ctx.textAlign;
    const savedBaseline = ctx.textBaseline;
    if (options.font) ctx.font = options.font;
    if (options.align) ctx.textAlign = options.align;
    if (options.baseline) ctx.textBaseline = options.baseline;
    if (options.maxWidth) {
      ctx.fillText(text, x, y, options.maxWidth);
    } else {
      ctx.fillText(text, x, y);
    }
    ctx.font = savedFont;
    ctx.textAlign = savedAlign;
    ctx.textBaseline = savedBaseline;
  }
  function measureText(ctx, text, font) {
    const savedFont = ctx.font;
    if (font) ctx.font = font;
    const metrics = ctx.measureText(text);
    if (font) ctx.font = savedFont;
    return metrics;
  }
  function withState(ctx, callback) {
    ctx.save();
    try {
      callback();
    } finally {
      ctx.restore();
    }
  }
  function withTransform(ctx, transform, callback) {
    ctx.save();
    if (transform.translate) {
      ctx.translate(transform.translate.x, transform.translate.y);
    }
    if (transform.rotate !== void 0) {
      ctx.rotate(transform.rotate);
    }
    if (transform.scale !== void 0) {
      if (typeof transform.scale === "number") {
        ctx.scale(transform.scale, transform.scale);
      } else {
        ctx.scale(transform.scale.x, transform.scale.y);
      }
    }
    try {
      callback();
    } finally {
      ctx.restore();
    }
  }
  function drawRoundedPolygon(ctx, vertices, radius = 0) {
    if (vertices.length < 3) return;
    ctx.beginPath();
    if (radius <= 0) {
      vertices.forEach((v, i) => {
        if (i === 0) ctx.moveTo(v.x, v.y);
        else ctx.lineTo(v.x, v.y);
      });
      ctx.closePath();
      return;
    }
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % n];
      const prev = vertices[(i - 1 + n) % n];
      const v1x = prev.x - curr.x;
      const v1y = prev.y - curr.y;
      const v2x = next.x - curr.x;
      const v2y = next.y - curr.y;
      const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
      const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
      if (len1 > 0 && len2 > 0) {
        const n1x = v1x / len1;
        const n1y = v1y / len1;
        const n2x = v2x / len2;
        const n2y = v2y / len2;
        const angle2 = Math.acos(Math.max(-1, Math.min(1, n1x * n2x + n1y * n2y)));
        const tangentLength = radius / Math.tan(angle2 / 2);
        const maxTangent = Math.min(len1, len2) * 0.5;
        const actualTangent = Math.min(tangentLength, maxTangent);
        const p1x = curr.x + n1x * actualTangent;
        const p1y = curr.y + n1y * actualTangent;
        const p2x = curr.x + n2x * actualTangent;
        const p2y = curr.y + n2y * actualTangent;
        if (i === 0) {
          ctx.moveTo(p1x, p1y);
        } else {
          ctx.lineTo(p1x, p1y);
        }
        ctx.quadraticCurveTo(curr.x, curr.y, p2x, p2y);
      }
    }
    ctx.closePath();
  }

  // lib/template-utils/color.ts
  var color_exports = {};
  __export(color_exports, {
    adjustBrightness: () => adjustBrightness,
    adjustSaturation: () => adjustSaturation,
    hexToHsl: () => hexToHsl,
    hslToHex: () => hslToHex,
    interpolate: () => interpolate,
    parseColor: () => parseColor,
    rotateHue: () => rotateHue,
    spectrum: () => spectrum,
    withAlpha: () => withAlpha
  });
  function hexToHsl(hex) {
    hex = hex.replace("#", "");
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
          break;
        case g:
          h = ((b - r) / d + 2) / 6;
          break;
        case b:
          h = ((r - g) / d + 4) / 6;
          break;
      }
    }
    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }
  function hslToHex(h, s, l) {
    h = h / 360;
    s = s / 100;
    l = l / 100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p2, q2, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2) return q2;
        if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        return p2;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    const toHex = (x) => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }
  function interpolate(color1, color2, t) {
    t = Math.max(0, Math.min(1, t));
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    const r = Math.round(c1.r + (c2.r - c1.r) * t);
    const g = Math.round(c1.g + (c2.g - c1.g) * t);
    const b = Math.round(c1.b + (c2.b - c1.b) * t);
    return rgbToHex(r, g, b);
  }
  function adjustBrightness(color, amount) {
    const hsl = hexToHsl(color);
    hsl.l = Math.max(0, Math.min(100, hsl.l + amount * 100));
    return hslToHex(hsl.h, hsl.s, hsl.l);
  }
  function adjustSaturation(color, amount) {
    const hsl = hexToHsl(color);
    hsl.s = Math.max(0, Math.min(100, hsl.s + amount * 100));
    return hslToHex(hsl.h, hsl.s, hsl.l);
  }
  function rotateHue(color, degrees) {
    const hsl = hexToHsl(color);
    hsl.h = (hsl.h + degrees) % 360;
    if (hsl.h < 0) hsl.h += 360;
    return hslToHex(hsl.h, hsl.s, hsl.l);
  }
  function spectrum(t) {
    t = Math.max(0, Math.min(1, t));
    const hue = t * 360;
    return hslToHex(hue, 70, 50);
  }
  function parseColor(color) {
    if (color.startsWith("#")) {
      const rgb = hexToRgb(color);
      return { ...rgb, a: 1 };
    }
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (match) {
      return {
        r: parseInt(match[1]),
        g: parseInt(match[2]),
        b: parseInt(match[3]),
        a: match[4] ? parseFloat(match[4]) : 1
      };
    }
    return { r: 0, g: 0, b: 0, a: 1 };
  }
  function withAlpha(color, alpha) {
    const { r, g, b } = parseColor(color);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  function hexToRgb(hex) {
    hex = hex.replace("#", "");
    return {
      r: parseInt(hex.substring(0, 2), 16),
      g: parseInt(hex.substring(2, 4), 16),
      b: parseInt(hex.substring(4, 6), 16)
    };
  }
  function rgbToHex(r, g, b) {
    const toHex = (n) => {
      const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  // lib/template-utils/math.ts
  var math_exports = {};
  __export(math_exports, {
    angle: () => angle,
    clamp: () => clamp,
    distance: () => distance,
    ease: () => ease,
    lerp: () => lerp,
    map: () => map,
    noise2D: () => noise2D,
    random: () => random,
    randomInt: () => randomInt,
    smoothstep: () => smoothstep,
    toDegrees: () => toDegrees,
    toRadians: () => toRadians,
    wrap: () => wrap
  });
  function map(value, inMin, inMax, outMin, outMax) {
    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function lerp(a, b, t) {
    return a + (b - a) * t;
  }
  function smoothstep(edge0, edge1, x) {
    const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }
  function toRadians(degrees) {
    return degrees * (Math.PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / Math.PI);
  }
  var ease = {
    // Quadratic
    inQuad: (t) => t * t,
    outQuad: (t) => t * (2 - t),
    inOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    // Cubic
    inCubic: (t) => t * t * t,
    outCubic: (t) => --t * t * t + 1,
    inOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    // Quartic
    inQuart: (t) => t * t * t * t,
    outQuart: (t) => 1 - --t * t * t * t,
    inOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
    // Quintic
    inQuint: (t) => t * t * t * t * t,
    outQuint: (t) => 1 + --t * t * t * t * t,
    inOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
    // Sine
    inSine: (t) => 1 - Math.cos(t * Math.PI / 2),
    outSine: (t) => Math.sin(t * Math.PI / 2),
    inOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
    // Exponential
    inExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
    outExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
    inOutExpo: (t) => {
      if (t === 0) return 0;
      if (t === 1) return 1;
      if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
      return (2 - Math.pow(2, -20 * t + 10)) / 2;
    },
    // Circular
    inCirc: (t) => 1 - Math.sqrt(1 - t * t),
    outCirc: (t) => Math.sqrt(1 - --t * t),
    inOutCirc: (t) => {
      if (t < 0.5) return (1 - Math.sqrt(1 - 4 * t * t)) / 2;
      return (Math.sqrt(1 - (-2 * t + 2) * (-2 * t + 2)) + 1) / 2;
    },
    // Elastic
    inElastic: (t) => {
      if (t === 0) return 0;
      if (t === 1) return 1;
      return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * (2 * Math.PI / 3));
    },
    outElastic: (t) => {
      if (t === 0) return 0;
      if (t === 1) return 1;
      return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI / 3)) + 1;
    },
    inOutElastic: (t) => {
      if (t === 0) return 0;
      if (t === 1) return 1;
      if (t < 0.5) {
        return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI / 4.5))) / 2;
      }
      return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI / 4.5)) / 2 + 1;
    },
    // Back
    inBack: (t) => {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return c3 * t * t * t - c1 * t * t;
    },
    outBack: (t) => {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    },
    inOutBack: (t) => {
      const c1 = 1.70158;
      const c2 = c1 * 1.525;
      if (t < 0.5) {
        return Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2;
      }
      return (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
    },
    // Bounce
    inBounce: (t) => 1 - ease.outBounce(1 - t),
    outBounce: (t) => {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      } else if (t < 2 / 2.75) {
        t -= 1.5 / 2.75;
        return 7.5625 * t * t + 0.75;
      } else if (t < 2.5 / 2.75) {
        t -= 2.25 / 2.75;
        return 7.5625 * t * t + 0.9375;
      } else {
        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
      }
    },
    inOutBounce: (t) => {
      if (t < 0.5) return ease.inBounce(t * 2) / 2;
      return ease.outBounce(t * 2 - 1) / 2 + 0.5;
    }
  };
  function noise2D(x, y, seed = 0) {
    const n = Math.sin(x * 12.9898 + y * 78.233 + seed * 43758.5453);
    return n * 43758.5453 % 1;
  }
  function random(min, max) {
    return Math.random() * (max - min) + min;
  }
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function angle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
  function wrap(value, max) {
    return (value % max + max) % max;
  }

  // lib/template-utils/debug.ts
  var debug_exports = {};
  __export(debug_exports, {
    assert: () => assert,
    clearPerformanceData: () => clearPerformanceData,
    drawGrid: () => drawGrid,
    error: () => error,
    getPerformanceSummary: () => getPerformanceSummary,
    log: () => log,
    mark: () => mark,
    measure: () => measure,
    time: () => time,
    timeEnd: () => timeEnd,
    trace: () => trace,
    visualize: () => visualize,
    warn: () => warn
  });
  var isDevelopment = true;
  var performanceMarks = /* @__PURE__ */ new Map();
  var performanceMeasures = /* @__PURE__ */ new Map();
  function log(message, data) {
    if (!isDevelopment) return;
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0];
    const prefix = `[Template ${timestamp}]`;
    if (data !== void 0) {
      console.log(`${prefix} ${message}`, data);
    } else {
      console.log(`${prefix} ${message}`);
    }
  }
  function warn(message, data) {
    if (!isDevelopment) return;
    const prefix = "[Template Warning]";
    if (data !== void 0) {
      console.warn(`${prefix} ${message}`, data);
    } else {
      console.warn(`${prefix} ${message}`);
    }
  }
  function error(message, error2) {
    const prefix = "[Template Error]";
    if (isDevelopment && error2) {
      console.error(`${prefix} ${message}`, error2);
      if (error2.stack) {
        console.error("Stack trace:", error2.stack);
      }
    } else {
      console.error(`${prefix} ${message}`);
    }
  }
  function trace(label, data) {
    if (!isDevelopment) return;
    const stack = new Error().stack?.split("\\n")[2]?.trim() || "unknown";
    if (data !== void 0) {
      console.debug(`[Trace] ${label} at ${stack}`, data);
    } else {
      console.debug(`[Trace] ${label} at ${stack}`);
    }
  }
  function time(label) {
    if (!isDevelopment) return;
    performanceMarks.set(label, performance.now());
    log(`Timer started: ${label}`);
  }
  function timeEnd(label) {
    if (!isDevelopment) return;
    const startTime = performanceMarks.get(label);
    if (startTime === void 0) {
      warn(`Timer '${label}' was not started`);
      return;
    }
    const duration = performance.now() - startTime;
    performanceMarks.delete(label);
    if (!performanceMeasures.has(label)) {
      performanceMeasures.set(label, []);
    }
    performanceMeasures.get(label).push(duration);
    log(`Timer ended: ${label} - ${duration.toFixed(2)}ms`);
  }
  function mark(label) {
    if (!isDevelopment) return;
    performance.mark(`template-${label}`);
    trace(`Performance mark: ${label}`);
  }
  function measure(measureName, startMark, endMark) {
    if (!isDevelopment) return;
    try {
      if (endMark) {
        performance.measure(
          `template-${measureName}`,
          `template-${startMark}`,
          `template-${endMark}`
        );
      } else {
        performance.measure(
          `template-${measureName}`,
          `template-${startMark}`
        );
      }
      const entries = performance.getEntriesByName(`template-${measureName}`);
      if (entries.length > 0) {
        const duration = entries[entries.length - 1].duration;
        log(`Measure '${measureName}': ${duration.toFixed(2)}ms`);
      }
    } catch (e) {
      warn(`Failed to measure '${measureName}'`, e);
    }
  }
  function getPerformanceSummary() {
    if (!isDevelopment) return null;
    const summary = {};
    performanceMeasures.forEach((measurements, label) => {
      if (measurements.length === 0) return;
      const sum = measurements.reduce((a, b) => a + b, 0);
      const avg = sum / measurements.length;
      const min = Math.min(...measurements);
      const max = Math.max(...measurements);
      summary[label] = { count: measurements.length, avg, min, max };
    });
    return summary;
  }
  function assert(condition, message) {
    if (!isDevelopment) return;
    if (!condition) {
      error(`Assertion failed: ${message}`);
      throw new Error(`Template assertion failed: ${message}`);
    }
  }
  function visualize(ctx, label, value, x, y) {
    if (!isDevelopment) return;
    ctx.save();
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(x, y - 12, 200, 16);
    ctx.fillStyle = "#00ff00";
    ctx.font = "10px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const text = `${label}: ${JSON.stringify(value)}`;
    ctx.fillText(text, x + 2, y - 4);
    ctx.restore();
  }
  function drawGrid(ctx, width, height, spacing = 50) {
    if (!isDevelopment) return;
    ctx.save();
    ctx.strokeStyle = "rgba(255, 0, 255, 0.1)";
    ctx.lineWidth = 1;
    for (let x = 0; x <= width; x += spacing) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    for (let y = 0; y <= height; y += spacing) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
    ctx.strokeStyle = "rgba(255, 0, 255, 0.3)";
    ctx.beginPath();
    ctx.moveTo(width / 2, 0);
    ctx.lineTo(width / 2, height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    ctx.restore();
  }
  function clearPerformanceData() {
    if (!isDevelopment) return;
    performanceMarks.clear();
    performanceMeasures.clear();
    log("Performance data cleared");
  }

  // lib/template-utils/background.ts
  var background_exports = {};
  __export(background_exports, {
    apply: () => apply,
    clear: () => clear2,
    noise: () => noise,
    pattern: () => pattern,
    radialGradient: () => radialGradient
  });
  function apply(ctx, width, height, params) {
    const type = params.backgroundType || "transparent";
    if (type === "transparent") {
      return;
    }
    ctx.save();
    const opacity = params.backgroundOpacity ?? 1;
    ctx.globalAlpha = opacity;
    if (type === "solid") {
      const color = params.backgroundColor || "#ffffff";
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
    } else if (type === "gradient") {
      const startColor = params.backgroundGradientStart || params.backgroundColor || "#ffffff";
      const endColor = params.backgroundGradientEnd || "#f0f0f0";
      const direction = params.backgroundGradientDirection || 0;
      const radians = direction * Math.PI / 180;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.sqrt(width * width + height * height) / 2;
      const x1 = centerX - Math.cos(radians) * radius;
      const y1 = centerY - Math.sin(radians) * radius;
      const x2 = centerX + Math.cos(radians) * radius;
      const y2 = centerY + Math.sin(radians) * radius;
      const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
      gradient.addColorStop(0, startColor);
      gradient.addColorStop(1, endColor);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }
    ctx.restore();
  }
  function radialGradient(ctx, width, height, colors, centerX, centerY, radius) {
    ctx.save();
    const cx = centerX ?? width / 2;
    const cy = centerY ?? height / 2;
    const r = radius ?? Math.max(width, height) / 2;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    colors.forEach((color, i) => {
      const stop = i / (colors.length - 1);
      gradient.addColorStop(stop, color);
    });
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    ctx.restore();
  }
  function pattern(ctx, width, height, patternType, color = "rgba(0, 0, 0, 0.1)", spacing = 20) {
    ctx.save();
    if (patternType === "dots") {
      ctx.fillStyle = color;
      for (let x = spacing / 2; x < width; x += spacing) {
        for (let y = spacing / 2; y < height; y += spacing) {
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    } else if (patternType === "lines") {
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      for (let i = -height; i < width + height; i += spacing) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i + height, height);
        ctx.stroke();
      }
    } else if (patternType === "grid") {
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      for (let x = 0; x <= width; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y <= height; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }
  function noise(ctx, width, height, intensity = 0.1, monochrome = true) {
    ctx.save();
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      if (monochrome) {
        const value = Math.random() * 255 * intensity;
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      } else {
        data[i] = Math.random() * 255 * intensity;
        data[i + 1] = Math.random() * 255 * intensity;
        data[i + 2] = Math.random() * 255 * intensity;
      }
      data[i + 3] = 255 * intensity;
    }
    ctx.putImageData(imageData, 0, 0);
    ctx.restore();
  }
  function clear2(ctx, width, height, color) {
    if (color) {
      ctx.save();
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    } else {
      ctx.clearRect(0, 0, width, height);
    }
  }

  // lib/template-utils/shape.ts
  var shape_exports = {};
  __export(shape_exports, {
    arrow: () => arrow,
    burst: () => burst,
    gear: () => gear,
    heart: () => heart,
    polygon: () => polygon,
    roundedRect: () => roundedRect,
    spiral: () => spiral,
    star: () => star,
    wave: () => wave
  });
  function polygon(ctx, x, y, radius, sides, rotation = 0) {
    if (sides < 3) return;
    ctx.beginPath();
    const angleStep = Math.PI * 2 / sides;
    for (let i = 0; i < sides; i++) {
      const angle2 = i * angleStep + rotation;
      const px = x + Math.cos(angle2) * radius;
      const py = y + Math.sin(angle2) * radius;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
  }
  function star(ctx, x, y, outerRadius, innerRadius, points, rotation = 0) {
    if (points < 2) return;
    ctx.beginPath();
    const angleStep = Math.PI / points;
    for (let i = 0; i < points * 2; i++) {
      const angle2 = i * angleStep + rotation;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const px = x + Math.cos(angle2) * radius;
      const py = y + Math.sin(angle2) * radius;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
  }
  function wave(ctx, x, y, width, amplitude, frequency, phase = 0, resolution = 50) {
    ctx.beginPath();
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const px = x + t * width;
      const py = y + Math.sin(t * frequency * Math.PI * 2 + phase) * amplitude;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
  }
  function spiral(ctx, x, y, startRadius, endRadius, rotations, resolution = 100) {
    ctx.beginPath();
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const angle2 = t * rotations * Math.PI * 2;
      const radius = startRadius + (endRadius - startRadius) * t;
      const px = x + Math.cos(angle2) * radius;
      const py = y + Math.sin(angle2) * radius;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
  }
  function heart(ctx, x, y, size, rotation = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.5);
    ctx.bezierCurveTo(
      -size * 0.5,
      -size * 0.8,
      -size,
      -size * 0.5,
      -size,
      -size * 0.1
    );
    ctx.bezierCurveTo(
      -size,
      size * 0.3,
      -size * 0.5,
      size * 0.6,
      0,
      size
    );
    ctx.bezierCurveTo(
      size * 0.5,
      size * 0.6,
      size,
      size * 0.3,
      size,
      -size * 0.1
    );
    ctx.bezierCurveTo(
      size,
      -size * 0.5,
      size * 0.5,
      -size * 0.8,
      0,
      -size * 0.5
    );
    ctx.closePath();
    ctx.restore();
  }
  function arrow(ctx, fromX, fromY, toX, toY, headSize = 10) {
    const angle2 = Math.atan2(toY - fromY, toX - fromX);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.moveTo(toX, toY);
    ctx.lineTo(
      toX - headSize * Math.cos(angle2 - Math.PI / 6),
      toY - headSize * Math.sin(angle2 - Math.PI / 6)
    );
    ctx.moveTo(toX, toY);
    ctx.lineTo(
      toX - headSize * Math.cos(angle2 + Math.PI / 6),
      toY - headSize * Math.sin(angle2 + Math.PI / 6)
    );
  }
  function roundedRect(ctx, x, y, width, height, radius) {
    const r = typeof radius === "number" ? { tl: radius, tr: radius, br: radius, bl: radius } : { tl: radius.tl || 0, tr: radius.tr || 0, br: radius.br || 0, bl: radius.bl || 0 };
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + width - r.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + r.tr);
    ctx.lineTo(x + width, y + height - r.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - r.br, y + height);
    ctx.lineTo(x + r.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
  }
  function gear(ctx, x, y, outerRadius, innerRadius, teeth, toothDepth = 0.3, rotation = 0) {
    ctx.beginPath();
    const angleStep = Math.PI * 2 / (teeth * 2);
    for (let i = 0; i < teeth * 2; i++) {
      const angle2 = i * angleStep + rotation;
      const radius = i % 2 === 0 ? outerRadius : outerRadius * (1 - toothDepth);
      const px = x + Math.cos(angle2) * radius;
      const py = y + Math.sin(angle2) * radius;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
    ctx.moveTo(x + innerRadius, y);
    ctx.arc(x, y, innerRadius, 0, Math.PI * 2, true);
  }
  function burst(ctx, x, y, innerRadius, outerRadius, points, rotation = 0) {
    ctx.beginPath();
    const angleStep = Math.PI / points;
    for (let i = 0; i < points * 2; i++) {
      const angle2 = i * angleStep + rotation;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const px = x + Math.cos(angle2) * radius;
      const py = y + Math.sin(angle2) * radius;
      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
  }

  // lib/template-utils/index.ts
  var utils = {
    canvas: canvas_exports,
    color: color_exports,
    math: math_exports,
    debug: debug_exports,
    background: background_exports,
    shape: shape_exports
  };
  return __toCommonJS(index_exports);
})();
