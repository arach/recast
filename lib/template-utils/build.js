#!/usr/bin/env node

/**
 * Build script for template utilities
 * Transpiles TypeScript utils to JavaScript for template consumption
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const UTILS_DIR = __dirname;
const OUTPUT_FILE = path.join(path.dirname(UTILS_DIR), 'template-utils.js');

console.log('üî® Building template utilities...');

try {
  // Use TypeScript compiler to build the utils
  // We'll use the project's TypeScript config but output as a single file
  const tsFiles = [
    'index.ts',
    'canvas.ts',
    'color.ts',
    'math.ts',
    'debug.ts',
    'background.ts',
    'shape.ts'
  ].map(file => path.join(UTILS_DIR, file));

  // First, check if TypeScript is available
  try {
    execSync('npx tsc --version', { stdio: 'ignore' });
  } catch (e) {
    console.error('‚ùå TypeScript not found. Please install it first.');
    process.exit(1);
  }

  // Create a temporary tsconfig for our build
  const tempConfig = {
    compilerOptions: {
      target: "ES2020",
      module: "ES2020",
      lib: ["ES2020", "DOM"],
      declaration: false,
      outFile: OUTPUT_FILE,
      rootDir: UTILS_DIR,
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      moduleResolution: "node",
      removeComments: false,
      inlineSourceMap: true
    },
    files: tsFiles
  };

  const tempConfigPath = path.join(UTILS_DIR, 'tsconfig.build.json');
  fs.writeFileSync(tempConfigPath, JSON.stringify(tempConfig, null, 2));

  console.log('üìù Compiling TypeScript...');
  
  // Use esbuild for better bundling
  const esbuildCmd = `npx esbuild ${path.join(UTILS_DIR, 'index.ts')} --bundle --format=iife --global-name=templateUtils --platform=browser --target=es2020 --outfile=${OUTPUT_FILE}`;
  
  try {
    execSync(esbuildCmd, { stdio: 'inherit' });
  } catch (e) {
    console.log('‚ö†Ô∏è  esbuild not found, falling back to tsc...');
    
    // Fallback to tsc with manual bundling
    execSync(`npx tsc -p ${tempConfigPath}`, { stdio: 'inherit' });
  }

  // Clean up temp config
  fs.unlinkSync(tempConfigPath);

  // Add header to the output file
  const header = `/**
 * ReFlow Template Utilities (Auto-generated)
 * 
 * This file is automatically generated from TypeScript sources.
 * Do not edit directly. Edit files in lib/template-utils/ instead.
 * 
 * Generated on: ${new Date().toISOString()}
 */

`;

  const content = fs.readFileSync(OUTPUT_FILE, 'utf8');
  
  // Wrap in IIFE if not already wrapped (for tsc output)
  let finalContent = content;
  if (!content.includes('templateUtils')) {
    finalContent = `${header}
(function() {
  'use strict';
  
${content}

  // Export for template use
  if (typeof window !== 'undefined') {
    window.templateUtils = { utils };
  }
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = { utils };
  }
})();
`;
  } else {
    finalContent = header + content;
  }

  fs.writeFileSync(OUTPUT_FILE, finalContent);

  console.log(`‚úÖ Build complete! Output: ${OUTPUT_FILE}`);
  
  // Also create a .d.ts file for TypeScript templates that want types
  const dtsContent = `/**
 * TypeScript definitions for ReFlow Template Utilities
 */

export * from './template-utils/index';
`;
  
  fs.writeFileSync(OUTPUT_FILE.replace('.js', '.d.ts'), dtsContent);
  console.log(`üìò TypeScript definitions created`);

} catch (error) {
  console.error('‚ùå Build failed:', error.message);
  process.exit(1);
}