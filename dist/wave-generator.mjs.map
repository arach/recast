{"version":3,"sources":["../core/wave-generator.ts"],"sourcesContent":["/**\n * Core wave generation engine for ReCast\n * This is the mathematical heart of the identity system\n */\n\nexport interface WavePoint {\n  x: number\n  y: number\n  intensity: number\n  phase: number\n}\n\nexport interface WaveParameters {\n  amplitude: number          // 0-100: Height of waves\n  frequency: number         // 0-20: Number of wave cycles  \n  phase: number            // 0-2Ï€: Wave offset\n  complexity: number       // 0-1: How many harmonics to add\n  chaos: number           // 0-1: Randomness factor\n  damping: number         // 0-1: How quickly waves decay\n  layers: number          // 1-5: Number of wave layers\n}\n\nexport interface GenerationOptions {\n  width: number\n  height: number\n  resolution: number      // Points per wave\n  time?: number          // For animations\n  seed?: string          // For reproducible randomness\n}\n\nexport class WaveGenerator {\n  private params: WaveParameters\n  private rng: () => number\n\n  constructor(params: WaveParameters, seed?: string) {\n    this.params = params\n    this.rng = seed ? this.seededRandom(seed) : Math.random\n  }\n\n  // Seeded random number generator for reproducible results\n  private seededRandom(seed: string): () => number {\n    let hash = 0\n    for (let i = 0; i < seed.length; i++) {\n      const char = seed.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash\n    }\n    \n    return () => {\n      hash = (hash * 9301 + 49297) % 233280\n      return hash / 233280\n    }\n  }\n\n  // Generate a single wave layer\n  private generateLayer(\n    options: GenerationOptions,\n    layerIndex: number,\n    time: number = 0\n  ): WavePoint[] {\n    const points: WavePoint[] = []\n    const { width, height, resolution } = options\n    const { amplitude, frequency, phase, complexity, chaos, damping } = this.params\n\n    // Layer-specific modifications\n    const layerFreq = frequency * (1 + layerIndex * 0.3)\n    const layerAmp = amplitude * Math.pow(damping, layerIndex)\n    const layerPhase = phase + (layerIndex * Math.PI / 4)\n\n    for (let i = 0; i < resolution; i++) {\n      const x = (i / resolution) * width\n      const t = i / resolution\n\n      // Base wave\n      let y = Math.sin((t * layerFreq * Math.PI * 2) + layerPhase + time)\n\n      // Add harmonics for complexity\n      for (let h = 2; h <= Math.ceil(complexity * 5); h++) {\n        const harmonicAmp = 1 / h\n        y += harmonicAmp * Math.sin((t * layerFreq * h * Math.PI * 2) + layerPhase + time)\n      }\n\n      // Add chaos\n      if (chaos > 0) {\n        y += (this.rng() - 0.5) * chaos\n      }\n\n      // Scale to amplitude\n      y = y * layerAmp\n\n      // Center vertically\n      y = height / 2 + y\n\n      // Calculate intensity (for visual effects like opacity/color)\n      const intensity = Math.abs(y - height / 2) / (height / 2)\n\n      points.push({\n        x,\n        y,\n        intensity,\n        phase: (t * layerFreq * Math.PI * 2) + layerPhase\n      })\n    }\n\n    return points\n  }\n\n  // Generate all wave layers\n  generate(options: GenerationOptions): WavePoint[][] {\n    const { layers } = this.params\n    const { time = 0 } = options\n    \n    const allLayers: WavePoint[][] = []\n\n    for (let i = 0; i < layers; i++) {\n      const layer = this.generateLayer(options, i, time)\n      allLayers.push(layer)\n    }\n\n    return allLayers\n  }\n\n  // Generate a wave-within-wave effect\n  generateNested(options: GenerationOptions): WavePoint[][] {\n    const containerWave = this.generate({\n      ...options,\n      resolution: Math.floor(options.resolution / 4)\n    })[0]\n\n    const nestedWaves: WavePoint[][] = []\n\n    // For each segment of the container wave\n    for (let i = 0; i < containerWave.length - 1; i++) {\n      const start = containerWave[i]\n      const end = containerWave[i + 1]\n\n      // Generate mini-waves between these points\n      const miniParams: WaveParameters = {\n        ...this.params,\n        amplitude: this.params.amplitude * 0.3,\n        frequency: this.params.frequency * 4\n      }\n\n      const miniGen = new WaveGenerator(miniParams)\n      const miniWave = miniGen.generateLayer({\n        width: end.x - start.x,\n        height: options.height,\n        resolution: 20\n      }, 0)\n\n      // Transform mini-wave to fit between container points\n      const transformed = miniWave.map(point => ({\n        ...point,\n        x: start.x + point.x,\n        y: start.y + (point.y - options.height / 2) * 0.3\n      }))\n\n      nestedWaves.push(transformed)\n    }\n\n    return [containerWave, ...nestedWaves.flat()] as WavePoint[][]\n  }\n\n  // Update parameters (for animation)\n  updateParams(params: Partial<WaveParameters>) {\n    this.params = { ...this.params, ...params }\n  }\n}"],"mappings":"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","names":[]}