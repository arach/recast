{"version":3,"sources":["../core/generative-engine.ts","../core/wave-generator.ts"],"sourcesContent":["/**\n * Core Generative Engine for ReCast\n * Mathematical foundation for creating parametric visual identities\n */\n\nexport interface GeneratedElement {\n  type: 'rect' | 'circle' | 'path' | 'polygon' | 'ellipse' | 'line'\n  props: Record<string, any>\n  style?: Record<string, any>\n  animationHints?: {\n    transformOrigin?: string\n    easingFunction?: string\n    duration?: number\n  }\n}\n\nexport interface GenerativeParameters {\n  // Core parameters shared by all generators\n  frequency: number      // 0-20: Speed/cycles of change\n  amplitude: number      // 0-100: Magnitude of change\n  complexity: number     // 0-1: Layers/harmonics/subdivisions\n  chaos: number         // 0-1: Randomness factor\n  damping: number       // 0-1: Decay/softening\n  layers: number        // 1-5: Number of overlapping elements\n  \n  // Shape-specific parameters (optional)\n  radius?: number       // For circles, spirals\n  sides?: number        // For polygons\n  barCount?: number     // For bars, waves\n  barSpacing?: number   // For discrete elements\n  rotation?: number     // Base rotation angle\n  scale?: number        // Size multiplier\n  \n  // Color parameters\n  hue?: number         // Base hue (0-360)\n  saturation?: number  // Color intensity (0-100)\n  lightness?: number   // Color brightness (0-100)\n  colorMode?: 'spectrum' | 'monochrome' | 'dual' | 'custom'\n  \n  // Animation parameters\n  animationSpeed?: number    // Speed multiplier for time-based changes\n  phaseOffset?: number      // Starting phase offset\n  \n  // Extensible for new parameters\n  [key: string]: any\n}\n\nexport interface GenerationOptions {\n  width: number\n  height: number\n  resolution: number      // Detail level/point count\n  time?: number          // Current animation time\n  seed?: string          // For reproducible randomness\n  centerX?: number       // Center point X (defaults to width/2)\n  centerY?: number       // Center point Y (defaults to height/2)\n  pixelRatio?: number    // For high-DPI displays\n}\n\nexport interface GeneratorMetadata {\n  name: string\n  description: string\n  category: 'geometric' | 'organic' | 'mathematical' | 'abstract'\n  supportedModes: string[]\n  defaultParameters: Partial<GenerativeParameters>\n  parameterRanges: Record<string, { min: number, max: number, step?: number }>\n}\n\nexport abstract class GeneratorBase {\n  protected params: GenerativeParameters\n  protected metadata: GeneratorMetadata\n  protected rng: () => number\n\n  constructor(params: GenerativeParameters, seed?: string) {\n    this.params = params\n    this.rng = seed ? this.createSeededRandom(seed) : Math.random\n  }\n\n  // Main generation method - must be implemented by subclasses\n  abstract generate(options: GenerationOptions): GeneratedElement[]\n\n  // Get metadata about this generator\n  getMetadata(): GeneratorMetadata {\n    return this.metadata\n  }\n\n  // Update parameters without recreating generator\n  updateParameters(newParams: Partial<GenerativeParameters>): void {\n    this.params = { ...this.params, ...newParams }\n  }\n\n  // Get current parameters\n  getParameters(): GenerativeParameters {\n    return { ...this.params }\n  }\n\n  // Seeded random number generator for reproducible results\n  private createSeededRandom(seed: string): () => number {\n    let hash = 0\n    for (let i = 0; i < seed.length; i++) {\n      const char = seed.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash\n    }\n    \n    return () => {\n      hash = (hash * 9301 + 49297) % 233280\n      return hash / 233280\n    }\n  }\n\n  // Utility methods for common calculations\n  protected calculatePhase(index: number, total: number, time: number = 0): number {\n    return (index / total) * this.params.frequency * Math.PI * 2 + time + (this.params.phaseOffset || 0)\n  }\n\n  protected applyDamping(value: number, distance: number): number {\n    return value * Math.pow(this.params.damping, distance)\n  }\n\n  protected addChaos(value: number, intensity: number = 1): number {\n    const chaosAmount = (this.rng() - 0.5) * this.params.chaos * intensity\n    return value + chaosAmount\n  }\n\n  protected scaleToCanvas(value: number, canvasSize: number): number {\n    return (value / 100) * canvasSize\n  }\n}\n\n// Registry for all available generators\nexport class GeneratorRegistry {\n  private static generators = new Map<string, typeof GeneratorBase>()\n\n  static register(name: string, generatorClass: typeof GeneratorBase): void {\n    this.generators.set(name, generatorClass)\n  }\n\n  static get(name: string): typeof GeneratorBase | undefined {\n    return this.generators.get(name)\n  }\n\n  static getAll(): string[] {\n    return Array.from(this.generators.keys())\n  }\n\n  static createGenerator(name: string, params: GenerativeParameters, seed?: string): GeneratorBase | null {\n    const GeneratorClass = this.generators.get(name)\n    if (!GeneratorClass) return null\n    \n    return new GeneratorClass(params, seed) as GeneratorBase\n  }\n}\n\n// Main engine that orchestrates multiple generators\nexport class GenerativeEngine {\n  private generators: Map<string, GeneratorBase> = new Map()\n\n  addGenerator(id: string, generator: GeneratorBase): void {\n    this.generators.set(id, generator)\n  }\n\n  removeGenerator(id: string): void {\n    this.generators.delete(id)\n  }\n\n  generate(options: GenerationOptions): Map<string, GeneratedElement[]> {\n    const results = new Map<string, GeneratedElement[]>()\n    \n    for (const [id, generator] of this.generators) {\n      try {\n        const elements = generator.generate(options)\n        results.set(id, elements)\n      } catch (error) {\n        console.warn(`Generator ${id} failed:`, error)\n        results.set(id, [])\n      }\n    }\n    \n    return results\n  }\n\n  // Generate with a single generator by name\n  generateSingle(generatorName: string, params: GenerativeParameters, options: GenerationOptions, seed?: string): GeneratedElement[] {\n    const generator = GeneratorRegistry.createGenerator(generatorName, params, seed)\n    if (!generator) {\n      throw new Error(`Unknown generator: ${generatorName}`)\n    }\n    \n    return generator.generate(options)\n  }\n}","/**\n * Wave-based generator for ReCast\n * Implements mathematical wave functions within the generative engine framework\n */\n\nimport { GeneratorBase, GeneratedElement, GenerativeParameters, GenerationOptions, GeneratorMetadata, GeneratorRegistry } from './generative-engine'\n\nexport interface WavePoint {\n  x: number\n  y: number\n  intensity: number\n  phase: number\n}\n\n// Legacy interface for backward compatibility\nexport interface WaveParameters {\n  amplitude: number          // 0-100: Height of waves\n  frequency: number         // 0-20: Number of wave cycles  \n  phase: number            // 0-2Ï€: Wave offset\n  complexity: number       // 0-1: How many harmonics to add\n  chaos: number           // 0-1: Randomness factor\n  damping: number         // 0-1: How quickly waves decay\n  layers: number          // 1-5: Number of wave layers\n}\n\nexport class WaveGenerator extends GeneratorBase {\n  constructor(params: GenerativeParameters | WaveParameters, seed?: string) {\n    // Convert legacy WaveParameters to GenerativeParameters if needed\n    const generativeParams: GenerativeParameters = 'barCount' in params ? params as GenerativeParameters : {\n      frequency: params.frequency,\n      amplitude: params.amplitude,\n      complexity: params.complexity,\n      chaos: params.chaos,\n      damping: params.damping,\n      layers: params.layers,\n      phaseOffset: 'phase' in params ? params.phase : 0\n    }\n    \n    super(generativeParams, seed)\n    \n    this.metadata = {\n      name: 'Wave Generator',\n      description: 'Creates smooth mathematical wave patterns with harmonics and complexity',\n      category: 'mathematical',\n      supportedModes: ['wave', 'wavebars'],\n      defaultParameters: {\n        frequency: 3,\n        amplitude: 50,\n        complexity: 0.3,\n        chaos: 0.1,\n        damping: 0.9,\n        layers: 2\n      },\n      parameterRanges: {\n        frequency: { min: 0.1, max: 20, step: 0.1 },\n        amplitude: { min: 0, max: 100, step: 1 },\n        complexity: { min: 0, max: 1, step: 0.01 },\n        chaos: { min: 0, max: 1, step: 0.01 },\n        damping: { min: 0, max: 1, step: 0.01 },\n        layers: { min: 1, max: 5, step: 1 }\n      }\n    }\n  }\n\n  // New unified generate method for GenerativeEngine compatibility\n  generate(options: GenerationOptions): GeneratedElement[] {\n    const layers = this.generateWavePoints(options)\n    const elements: GeneratedElement[] = []\n    \n    // Convert wave points to GeneratedElement format\n    layers.forEach((layer, layerIndex) => {\n      // For wave mode, create path elements\n      if (layer.length > 1) {\n        const pathData = layer.map((point, i) => \n          i === 0 ? `M ${point.x} ${point.y}` : `L ${point.x} ${point.y}`\n        ).join(' ')\n        \n        elements.push({\n          type: 'path',\n          props: {\n            d: pathData,\n            stroke: `hsl(${200 + layerIndex * 30}, 70%, 50%)`,\n            strokeWidth: Math.max(1, options.width / 200),\n            fill: 'none',\n            opacity: 0.8 - (layerIndex * 0.1)\n          }\n        })\n      }\n    })\n    \n    return elements\n  }\n\n\n  // Generate a single wave layer\n  private generateLayer(\n    options: GenerationOptions,\n    layerIndex: number,\n    time: number = 0\n  ): WavePoint[] {\n    const points: WavePoint[] = []\n    const { width, height, resolution } = options\n    const { amplitude, frequency, complexity, chaos, damping, phaseOffset } = this.params\n\n    // Layer-specific modifications\n    const layerFreq = frequency * (1 + layerIndex * 0.3)\n    const layerAmp = amplitude * Math.pow(damping, layerIndex)\n    const layerPhase = (phaseOffset || 0) + (layerIndex * Math.PI / 4)\n\n    for (let i = 0; i < resolution; i++) {\n      const x = (i / resolution) * width\n      const t = i / resolution\n\n      // Base wave\n      let y = Math.sin((t * layerFreq * Math.PI * 2) + layerPhase + time)\n\n      // Add harmonics for complexity\n      for (let h = 2; h <= Math.ceil(complexity * 5); h++) {\n        const harmonicAmp = 1 / h\n        y += harmonicAmp * Math.sin((t * layerFreq * h * Math.PI * 2) + layerPhase + time)\n      }\n\n      // Add chaos\n      if (chaos > 0) {\n        y += (this.rng() - 0.5) * chaos\n      }\n\n      // Scale to amplitude\n      y = y * layerAmp\n\n      // Center vertically\n      y = height / 2 + y\n\n      // Calculate intensity (for visual effects like opacity/color)\n      const intensity = Math.abs(y - height / 2) / (height / 2)\n\n      points.push({\n        x,\n        y,\n        intensity,\n        phase: (t * layerFreq * Math.PI * 2) + layerPhase\n      })\n    }\n\n    return points\n  }\n\n  // Legacy method - generates raw wave points (DEPRECATED: use generate() for new code)\n  generateWavePoints(options: GenerationOptions): WavePoint[][] {\n    const { layers } = this.params\n    const { time = 0 } = options\n    \n    const allLayers: WavePoint[][] = []\n\n    for (let i = 0; i < layers; i++) {\n      const layer = this.generateLayer(options, i, time)\n      allLayers.push(layer)\n    }\n\n    return allLayers\n  }\n\n  // Generate a wave-within-wave effect\n  generateNested(options: GenerationOptions): WavePoint[][] {\n    const containerWave = this.generateWavePoints({\n      ...options,\n      resolution: Math.floor(options.resolution / 4)\n    })[0]\n\n    const nestedWaves: WavePoint[][] = []\n\n    // For each segment of the container wave\n    for (let i = 0; i < containerWave.length - 1; i++) {\n      const start = containerWave[i]\n      const end = containerWave[i + 1]\n\n      // Generate mini-waves between these points\n      const miniParams: WaveParameters = {\n        ...this.params,\n        amplitude: this.params.amplitude * 0.3,\n        frequency: this.params.frequency * 4\n      }\n\n      const miniGen = new WaveGenerator(miniParams)\n      const miniWave = miniGen.generateLayer({\n        width: end.x - start.x,\n        height: options.height,\n        resolution: 20\n      }, 0)\n\n      // Transform mini-wave to fit between container points\n      const transformed = miniWave.map(point => ({\n        ...point,\n        x: start.x + point.x,\n        y: start.y + (point.y - options.height / 2) * 0.3\n      }))\n\n      nestedWaves.push(transformed)\n    }\n\n    return [containerWave, ...nestedWaves.flat()] as WavePoint[][]\n  }\n\n  // Legacy parameter update method (DEPRECATED: use updateParameters() for new code)\n  updateParams(params: Partial<WaveParameters>) {\n    const generativeParams: Partial<GenerativeParameters> = {\n      frequency: params.frequency,\n      amplitude: params.amplitude,\n      complexity: params.complexity,\n      chaos: params.chaos,\n      damping: params.damping,\n      layers: params.layers,\n      phaseOffset: 'phase' in params ? params.phase : undefined\n    }\n    this.updateParameters(generativeParams)\n  }\n}\n\n// Register the WaveGenerator with the GenerativeEngine\nGeneratorRegistry.register('wave', WaveGenerator)"],"mappings":";AAmEO,IAAe,gBAAf,MAA6B;AAAA,EAKlC,YAAY,QAA8B,MAAe;AACvD,SAAK,SAAS;AACd,SAAK,MAAM,OAAO,KAAK,mBAAmB,IAAI,IAAI,KAAK;AAAA,EACzD;AAAA;AAAA,EAMA,cAAiC;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGA,iBAAiB,WAAgD;AAC/D,SAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,UAAU;AAAA,EAC/C;AAAA;AAAA,EAGA,gBAAsC;AACpC,WAAO,EAAE,GAAG,KAAK,OAAO;AAAA,EAC1B;AAAA;AAAA,EAGQ,mBAAmB,MAA4B;AACrD,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAM,OAAO,KAAK,WAAW,CAAC;AAC9B,cAAS,QAAQ,KAAK,OAAQ;AAC9B,aAAO,OAAO;AAAA,IAChB;AAEA,WAAO,MAAM;AACX,cAAQ,OAAO,OAAO,SAAS;AAC/B,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AAAA;AAAA,EAGU,eAAe,OAAe,OAAe,OAAe,GAAW;AAC/E,WAAQ,QAAQ,QAAS,KAAK,OAAO,YAAY,KAAK,KAAK,IAAI,QAAQ,KAAK,OAAO,eAAe;AAAA,EACpG;AAAA,EAEU,aAAa,OAAe,UAA0B;AAC9D,WAAO,QAAQ,KAAK,IAAI,KAAK,OAAO,SAAS,QAAQ;AAAA,EACvD;AAAA,EAEU,SAAS,OAAe,YAAoB,GAAW;AAC/D,UAAM,eAAe,KAAK,IAAI,IAAI,OAAO,KAAK,OAAO,QAAQ;AAC7D,WAAO,QAAQ;AAAA,EACjB;AAAA,EAEU,cAAc,OAAe,YAA4B;AACjE,WAAQ,QAAQ,MAAO;AAAA,EACzB;AACF;AAGO,IAAM,oBAAN,MAAwB;AAAA,EAG7B,OAAO,SAAS,MAAc,gBAA4C;AACxE,SAAK,WAAW,IAAI,MAAM,cAAc;AAAA,EAC1C;AAAA,EAEA,OAAO,IAAI,MAAgD;AACzD,WAAO,KAAK,WAAW,IAAI,IAAI;AAAA,EACjC;AAAA,EAEA,OAAO,SAAmB;AACxB,WAAO,MAAM,KAAK,KAAK,WAAW,KAAK,CAAC;AAAA,EAC1C;AAAA,EAEA,OAAO,gBAAgB,MAAc,QAA8B,MAAqC;AACtG,UAAM,iBAAiB,KAAK,WAAW,IAAI,IAAI;AAC/C,QAAI,CAAC,eAAgB,QAAO;AAE5B,WAAO,IAAI,eAAe,QAAQ,IAAI;AAAA,EACxC;AACF;AArBa,kBACI,aAAa,oBAAI,IAAkC;;;AC1G7D,IAAM,gBAAN,MAAM,uBAAsB,cAAc;AAAA,EAC/C,YAAY,QAA+C,MAAe;AAExE,UAAM,mBAAyC,cAAc,SAAS,SAAiC;AAAA,MACrG,WAAW,OAAO;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,YAAY,OAAO;AAAA,MACnB,OAAO,OAAO;AAAA,MACd,SAAS,OAAO;AAAA,MAChB,QAAQ,OAAO;AAAA,MACf,aAAa,WAAW,SAAS,OAAO,QAAQ;AAAA,IAClD;AAEA,UAAM,kBAAkB,IAAI;AAE5B,SAAK,WAAW;AAAA,MACd,MAAM;AAAA,MACN,aAAa;AAAA,MACb,UAAU;AAAA,MACV,gBAAgB,CAAC,QAAQ,UAAU;AAAA,MACnC,mBAAmB;AAAA,QACjB,WAAW;AAAA,QACX,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,SAAS;AAAA,QACT,QAAQ;AAAA,MACV;AAAA,MACA,iBAAiB;AAAA,QACf,WAAW,EAAE,KAAK,KAAK,KAAK,IAAI,MAAM,IAAI;AAAA,QAC1C,WAAW,EAAE,KAAK,GAAG,KAAK,KAAK,MAAM,EAAE;AAAA,QACvC,YAAY,EAAE,KAAK,GAAG,KAAK,GAAG,MAAM,KAAK;AAAA,QACzC,OAAO,EAAE,KAAK,GAAG,KAAK,GAAG,MAAM,KAAK;AAAA,QACpC,SAAS,EAAE,KAAK,GAAG,KAAK,GAAG,MAAM,KAAK;AAAA,QACtC,QAAQ,EAAE,KAAK,GAAG,KAAK,GAAG,MAAM,EAAE;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,SAAS,SAAgD;AACvD,UAAM,SAAS,KAAK,mBAAmB,OAAO;AAC9C,UAAM,WAA+B,CAAC;AAGtC,WAAO,QAAQ,CAAC,OAAO,eAAe;AAEpC,UAAI,MAAM,SAAS,GAAG;AACpB,cAAM,WAAW,MAAM;AAAA,UAAI,CAAC,OAAO,MACjC,MAAM,IAAI,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC;AAAA,QAC/D,EAAE,KAAK,GAAG;AAEV,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,OAAO;AAAA,YACL,GAAG;AAAA,YACH,QAAQ,OAAO,MAAM,aAAa,EAAE;AAAA,YACpC,aAAa,KAAK,IAAI,GAAG,QAAQ,QAAQ,GAAG;AAAA,YAC5C,MAAM;AAAA,YACN,SAAS,MAAO,aAAa;AAAA,UAC/B;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA,EAIQ,cACN,SACA,YACA,OAAe,GACF;AACb,UAAM,SAAsB,CAAC;AAC7B,UAAM,EAAE,OAAO,QAAQ,WAAW,IAAI;AACtC,UAAM,EAAE,WAAW,WAAW,YAAY,OAAO,SAAS,YAAY,IAAI,KAAK;AAG/E,UAAM,YAAY,aAAa,IAAI,aAAa;AAChD,UAAM,WAAW,YAAY,KAAK,IAAI,SAAS,UAAU;AACzD,UAAM,cAAc,eAAe,KAAM,aAAa,KAAK,KAAK;AAEhE,aAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,YAAM,IAAK,IAAI,aAAc;AAC7B,YAAM,IAAI,IAAI;AAGd,UAAI,IAAI,KAAK,IAAK,IAAI,YAAY,KAAK,KAAK,IAAK,aAAa,IAAI;AAGlE,eAAS,IAAI,GAAG,KAAK,KAAK,KAAK,aAAa,CAAC,GAAG,KAAK;AACnD,cAAM,cAAc,IAAI;AACxB,aAAK,cAAc,KAAK,IAAK,IAAI,YAAY,IAAI,KAAK,KAAK,IAAK,aAAa,IAAI;AAAA,MACnF;AAGA,UAAI,QAAQ,GAAG;AACb,cAAM,KAAK,IAAI,IAAI,OAAO;AAAA,MAC5B;AAGA,UAAI,IAAI;AAGR,UAAI,SAAS,IAAI;AAGjB,YAAM,YAAY,KAAK,IAAI,IAAI,SAAS,CAAC,KAAK,SAAS;AAEvD,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAQ,IAAI,YAAY,KAAK,KAAK,IAAK;AAAA,MACzC,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,mBAAmB,SAA2C;AAC5D,UAAM,EAAE,OAAO,IAAI,KAAK;AACxB,UAAM,EAAE,OAAO,EAAE,IAAI;AAErB,UAAM,YAA2B,CAAC;AAElC,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,YAAM,QAAQ,KAAK,cAAc,SAAS,GAAG,IAAI;AACjD,gBAAU,KAAK,KAAK;AAAA,IACtB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,eAAe,SAA2C;AACxD,UAAM,gBAAgB,KAAK,mBAAmB;AAAA,MAC5C,GAAG;AAAA,MACH,YAAY,KAAK,MAAM,QAAQ,aAAa,CAAC;AAAA,IAC/C,CAAC,EAAE,CAAC;AAEJ,UAAM,cAA6B,CAAC;AAGpC,aAAS,IAAI,GAAG,IAAI,cAAc,SAAS,GAAG,KAAK;AACjD,YAAM,QAAQ,cAAc,CAAC;AAC7B,YAAM,MAAM,cAAc,IAAI,CAAC;AAG/B,YAAM,aAA6B;AAAA,QACjC,GAAG,KAAK;AAAA,QACR,WAAW,KAAK,OAAO,YAAY;AAAA,QACnC,WAAW,KAAK,OAAO,YAAY;AAAA,MACrC;AAEA,YAAM,UAAU,IAAI,eAAc,UAAU;AAC5C,YAAM,WAAW,QAAQ,cAAc;AAAA,QACrC,OAAO,IAAI,IAAI,MAAM;AAAA,QACrB,QAAQ,QAAQ;AAAA,QAChB,YAAY;AAAA,MACd,GAAG,CAAC;AAGJ,YAAM,cAAc,SAAS,IAAI,YAAU;AAAA,QACzC,GAAG;AAAA,QACH,GAAG,MAAM,IAAI,MAAM;AAAA,QACnB,GAAG,MAAM,KAAK,MAAM,IAAI,QAAQ,SAAS,KAAK;AAAA,MAChD,EAAE;AAEF,kBAAY,KAAK,WAAW;AAAA,IAC9B;AAEA,WAAO,CAAC,eAAe,GAAG,YAAY,KAAK,CAAC;AAAA,EAC9C;AAAA;AAAA,EAGA,aAAa,QAAiC;AAC5C,UAAM,mBAAkD;AAAA,MACtD,WAAW,OAAO;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,YAAY,OAAO;AAAA,MACnB,OAAO,OAAO;AAAA,MACd,SAAS,OAAO;AAAA,MAChB,QAAQ,OAAO;AAAA,MACf,aAAa,WAAW,SAAS,OAAO,QAAQ;AAAA,IAClD;AACA,SAAK,iBAAiB,gBAAgB;AAAA,EACxC;AACF;AAGA,kBAAkB,SAAS,QAAQ,aAAa;","names":[]}